"""
Module 5: Exporter - TradingView Pine Script and NautilusTrader Export

This module translates the signals and strategies generated by the FinPattern-Engine
into formats usable by popular trading platforms.

Key Features:
1. TradingView Pine Script v5 generation for signal visualization
2. NautilusTrader strategy export for backtesting and live trading
3. GUI integration for one-click export
4. Customizable templates for different export formats
"""

import pandas as pd
from pathlib import Path
import json
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional

MODULE_VERSION = "1.0"

def _log_progress(out_dir: Path, step: str, percent: int, message: str):
    """Progress logging for the Exporter module"""
    log_entry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "module": "exporter",
        "module_version": MODULE_VERSION,
        "step": step,
        "percent": percent,
        "message": message
    }
    
    log_file = out_dir / "progress.jsonl"
    with open(log_file, "a") as f:
        f.write(json.dumps(log_entry) + "\n")

class NautilusTraderExporter:
    """
    Generates NautilusTrader strategy from labeled events
    """
    
    def __init__(self, events: pd.DataFrame, strategy_name: str = "FinPatternStrategy"):
        """
        Initialize the NautilusTraderExporter
        
        Args:
            events: DataFrame of labeled events
            strategy_name: Name of the strategy class
        """
        self.events = events
        self.strategy_name = strategy_name.replace(" ", "").replace("-", "")
    
    def _generate_imports(self) -> str:
        """Generate the necessary imports for NautilusTrader"""
        return """from decimal import Decimal
from nautilus_trader.core.message import Event
from nautilus_trader.model.data import Bar
from nautilus_trader.model.enums import OrderSide, TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import CurrencyPair
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.trading.strategy import Strategy
from nautilus_trader.model.position import Position
import pandas as pd
from datetime import datetime, timezone

"""
    
    def _generate_class_header(self) -> str:
        """Generate the strategy class header"""
        return f"""class {self.strategy_name}(Strategy):
    \"\"\"
    FinPattern-Engine generated strategy for NautilusTrader
    
    Generated from {len(self.events)} labeled events
    Timestamp: {datetime.now(timezone.utc).isoformat()}
    \"\"\"
    
    def __init__(self, config=None):
        super().__init__(config)
        
        # Strategy parameters
        self.instrument_id = None
        self.trade_size = Decimal("10000")  # Default position size
        
        # Signal tracking
        self.entry_signals = self._load_entry_signals()
        self.exit_signals = self._load_exit_signals()
        
        # Position tracking
        self.current_position = None
        self.entry_time = None
    
"""
    
    def _generate_signal_loading(self) -> str:
        """Generate methods to load entry and exit signals"""
        
        # Extract entry signals
        long_entries = self.events[self.events["label"] == 1]
        short_entries = self.events[self.events["label"] == -1]
        
        # Extract exit signals
        tp_exits = self.events[self.events["hit_type"] == 1]
        sl_exits = self.events[self.events["hit_type"] == -1]
        
        code = """    def _load_entry_signals(self):
        \"\"\"Load entry signals from FinPattern-Engine analysis\"\"\"
        entry_signals = {
            'long': ["""
        
        # Add long entry timestamps
        for _, row in long_entries.iterrows():
            ts = int(row["entry_time"].timestamp() * 1000000000)  # Nanoseconds
            code += f"\n                {ts},"
        
        code += """
            ],
            'short': ["""
        
        # Add short entry timestamps  
        for _, row in short_entries.iterrows():
            ts = int(row["entry_time"].timestamp() * 1000000000)  # Nanoseconds
            code += f"\n                {ts},"
        
        code += """
            ]
        }
        return entry_signals
    
    def _load_exit_signals(self):
        \"\"\"Load exit signals from FinPattern-Engine analysis\"\"\"
        exit_signals = {
            'take_profit': ["""
        
        # Add TP exit timestamps
        for _, row in tp_exits.iterrows():
            ts = int(row["exit_time"].timestamp() * 1000000000)  # Nanoseconds
            code += f"\n                {ts},"
        
        code += """
            ],
            'stop_loss': ["""
        
        # Add SL exit timestamps
        for _, row in sl_exits.iterrows():
            ts = int(row["exit_time"].timestamp() * 1000000000)  # Nanoseconds
            code += f"\n                {ts},"
        
        code += """
            ]
        }
        return exit_signals
    
"""
        return code
    
    def _generate_strategy_logic(self) -> str:
        """Generate the main strategy logic"""
        return """    def on_start(self):
        \"\"\"Actions to be performed on strategy start\"\"\"
        self.log.info(f"Starting {self.__class__.__name__}")
        
        # Subscribe to bars for the instrument
        if self.instrument_id:
            self.subscribe_bars(self.instrument_id)
    
    def on_bar(self, bar: Bar):
        \"\"\"Handle incoming bar data\"\"\"
        current_time_ns = bar.ts_event
        
        # Check for entry signals
        if not self.current_position:
            self._check_entry_signals(bar, current_time_ns)
        else:
            # Check for exit signals if we have a position
            self._check_exit_signals(bar, current_time_ns)
    
    def _check_entry_signals(self, bar: Bar, current_time_ns: int):
        \"\"\"Check for entry signals\"\"\"
        
        # Check long entry signals
        if current_time_ns in self.entry_signals['long']:
            self.log.info(f"Long entry signal detected at {current_time_ns}")
            self._enter_long(bar)
        
        # Check short entry signals
        elif current_time_ns in self.entry_signals['short']:
            self.log.info(f"Short entry signal detected at {current_time_ns}")
            self._enter_short(bar)
    
    def _check_exit_signals(self, bar: Bar, current_time_ns: int):
        \"\"\"Check for exit signals\"\"\"
        
        if not self.current_position:
            return
        
        # Check take profit signals
        if current_time_ns in self.exit_signals['take_profit']:
            self.log.info(f"Take profit signal detected at {current_time_ns}")
            self._close_position(bar, "Take Profit")
        
        # Check stop loss signals
        elif current_time_ns in self.exit_signals['stop_loss']:
            self.log.info(f"Stop loss signal detected at {current_time_ns}")
            self._close_position(bar, "Stop Loss")
    
    def _enter_long(self, bar: Bar):
        \"\"\"Enter a long position\"\"\"
        order = MarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=bar.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.trade_size,
            time_in_force=TimeInForce.IOC,
        )
        
        self.submit_order(order)
        self.entry_time = bar.ts_event
        self.log.info(f"Submitted long market order: {order}")
    
    def _enter_short(self, bar: Bar):
        \"\"\"Enter a short position\"\"\"
        order = MarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=bar.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.trade_size,
            time_in_force=TimeInForce.IOC,
        )
        
        self.submit_order(order)
        self.entry_time = bar.ts_event
        self.log.info(f"Submitted short market order: {order}")
    
    def _close_position(self, bar: Bar, reason: str):
        \"\"\"Close the current position\"\"\"
        if not self.current_position:
            return
        
        # Determine order side for closing
        if self.current_position.side == PositionSide.LONG:
            order_side = OrderSide.SELL
        else:
            order_side = OrderSide.BUY
        
        order = MarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=bar.instrument_id,
            order_side=order_side,
            quantity=self.current_position.quantity,
            time_in_force=TimeInForce.IOC,
        )
        
        self.submit_order(order)
        self.log.info(f"Closed position due to {reason}: {order}")
    
    def on_position_opened(self, position: Position):
        \"\"\"Handle position opened event\"\"\"
        self.current_position = position
        self.log.info(f"Position opened: {position}")
    
    def on_position_closed(self, position: Position):
        \"\"\"Handle position closed event\"\"\"
        self.current_position = None
        self.entry_time = None
        self.log.info(f"Position closed: {position}")

"""
    
    def generate_strategy(self) -> str:
        """Generate the complete NautilusTrader strategy"""
        imports = self._generate_imports()
        class_header = self._generate_class_header()
        signal_loading = self._generate_signal_loading()
        strategy_logic = self._generate_strategy_logic()
        
        return imports + class_header + signal_loading + strategy_logic

class PineScriptExporter:
    """
    Generates TradingView Pine Script v5 from labeled events
    """
    
    def __init__(self, events: pd.DataFrame, strategy_name: str = "FinPattern Strategy"):
        """
        Initialize the PineScriptExporter
        
        Args:
            events: DataFrame of labeled events
            strategy_name: Name of the strategy for the Pine Script
        """
        self.events = events
        self.strategy_name = strategy_name
    
    def _generate_header(self) -> str:
        """
        Generate the Pine Script header
        """
        return f"""//@version=5
indicator("{self.strategy_name}", overlay=true)

// Generated by FinPattern-Engine v2.2
// Timestamp: {datetime.now(timezone.utc).isoformat()}

"""
    
    def _generate_entry_signals(self) -> str:
        """
        Generate Pine Script code for entry signals
        """
        long_entries = self.events[self.events["label"] == 1]
        short_entries = self.events[self.events["label"] == -1]
        
        pine_code = "// --- Entry Signals ---\n"
        
        # Long entries
        if not long_entries.empty:
            pine_code += "var long_entry_times = array.new_int()\n"
            for _, row in long_entries.iterrows():
                ts = int(row["entry_time"].timestamp() * 1000)
                pine_code += f"array.push(long_entry_times, {ts})\n"
            pine_code += "\nlong_signal = array.includes(long_entry_times, time_close)\n"
            pine_code += "plotshape(long_signal, title=\"Long Entry\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\n"
        
        # Short entries
        if not short_entries.empty:
            pine_code += "\nvar short_entry_times = array.new_int()\n"
            for _, row in short_entries.iterrows():
                ts = int(row["entry_time"].timestamp() * 1000)
                pine_code += f"array.push(short_entry_times, {ts})\n"
            pine_code += "\nshort_signal = array.includes(short_entry_times, time_close)\n"
            pine_code += "plotshape(short_signal, title=\"Short Entry\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)\n"
        
        return pine_code
    
    def _generate_exit_signals(self) -> str:
        """
        Generate Pine Script code for exit signals (TP/SL)
        """
        pine_code = "\n// --- Exit Signals ---\n"
        
        # Take Profit exits
        tp_exits = self.events[self.events["hit_type"] == 1]
        if not tp_exits.empty:
            pine_code += "var tp_exit_times = array.new_int()\n"
            for _, row in tp_exits.iterrows():
                ts = int(row["exit_time"].timestamp() * 1000)
                pine_code += f"array.push(tp_exit_times, {ts})\n"
            pine_code += "\ntp_exit_signal = array.includes(tp_exit_times, time_close)\n"
            pine_code += "plotshape(tp_exit_signal, title=\"Take Profit\", location=location.absolute, color=color.blue, style=shape.circle, size=size.tiny)\n"
        
        # Stop Loss exits
        sl_exits = self.events[self.events["hit_type"] == -1]
        if not sl_exits.empty:
            pine_code += "\nvar sl_exit_times = array.new_int()\n"
            for _, row in sl_exits.iterrows():
                ts = int(row["exit_time"].timestamp() * 1000)
                pine_code += f"array.push(sl_exit_times, {ts})\n"
            pine_code += "\nsl_exit_signal = array.includes(sl_exit_times, time_close)\n"
            pine_code += "plotshape(sl_exit_signal, title=\"Stop Loss\", location=location.absolute, color=color.orange, style=shape.xcross, size=size.tiny)\n"
        
        return pine_code
    
    def generate_script(self) -> str:
        """
        Generate the full Pine Script
        """
        header = self._generate_header()
        entries = self._generate_entry_signals()
        exits = self._generate_exit_signals()
        
        return header + entries + exits

def run(config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Main function for the Exporter module
    
    Args:
        config: Configuration dictionary with the following keys:
            - labeled_events_path: Path to labeled events (parquet file)
            - out_dir: Output directory
            - export_formats: List of formats to export (e.g., ["pine_script"])
            - strategy_name: Name for the exported strategy
    
    Returns:
        Dictionary with results and metadata
    """
    
    # Setup
    out_dir = Path(config["out_dir"])
    out_dir.mkdir(parents=True, exist_ok=True)
    
    _log_progress(out_dir, "start", 0, f"Exporter v{MODULE_VERSION} starting")
    
    # Load labeled events
    events_path = Path(config["labeled_events_path"])
    if not events_path.exists():
        raise FileNotFoundError(f"Labeled events file not found: {events_path}")
    
    _log_progress(out_dir, "load_events", 10, f"Loading labeled events from {events_path}")
    labeled_events = pd.read_parquet(events_path)
    
    # Ensure timestamp columns are datetime
    for col in ["entry_time", "exit_time"]:
        if col in labeled_events.columns:
            labeled_events[col] = pd.to_datetime(labeled_events[col], utc=True)
    
    export_formats = config.get("export_formats", ["pine_script"])
    strategy_name = config.get("strategy_name", "FinPattern Strategy")
    
    output_files = {}
    
    # Export to Pine Script
    if "pine_script" in export_formats:
        _log_progress(out_dir, "pine_script", 30, "Generating TradingView Pine Script")
        
        pine_exporter = PineScriptExporter(labeled_events, strategy_name)
        pine_script = pine_exporter.generate_script()
        
        # Save the script
        pine_script_path = out_dir / f"{strategy_name.replace(' ', '_').lower()}.pine"
        with open(pine_script_path, "w") as f:
            f.write(pine_script)
        
        output_files["pine_script"] = str(pine_script_path)
        _log_progress(out_dir, "pine_script", 50, f"Pine Script saved to {pine_script_path}")
    
    # Export to NautilusTrader
    if "nautilus_trader" in export_formats:
        _log_progress(out_dir, "nautilus_trader", 60, "Generating NautilusTrader strategy")
        
        nautilus_exporter = NautilusTraderExporter(labeled_events, strategy_name)
        nautilus_strategy = nautilus_exporter.generate_strategy()
        
        # Save the strategy
        nautilus_strategy_path = out_dir / f"{strategy_name.replace(' ', '_').lower()}_strategy.py"
        with open(nautilus_strategy_path, "w") as f:
            f.write(nautilus_strategy)
        
        output_files["nautilus_trader"] = str(nautilus_strategy_path)
        _log_progress(out_dir, "nautilus_trader", 70, f"NautilusTrader strategy saved to {nautilus_strategy_path}")
    
    # Generate summary
    _log_progress(out_dir, "summary", 80, "Generating export summary")
    
    summary = {
        "exported_formats": list(output_files.keys()),
        "output_files": output_files,
        "total_events_exported": len(labeled_events),
        "strategy_name": strategy_name
    }
    
    summary_path = out_dir / "export_summary.json"
    with open(summary_path, "w") as f:
        json.dump(summary, f, indent=2)
    
    # Save configuration
    config_path = out_dir / "config_used.json"
    with open(config_path, "w") as f:
        json.dump(config, f, indent=2, default=str)
    
    _log_progress(out_dir, "done", 100, f"Exporter v{MODULE_VERSION} completed successfully")
    
    return {
        "output_files": output_files,
        "summary_path": str(summary_path),
        "summary": summary,
        "module_version": MODULE_VERSION
    }

